#include <iostream>
#include <vector>
#include <list>

using namespace std;

// 用于邻接矩阵的深度优先搜索
void dfsMatrix(const vector<vector<int>>& matrix, vector<bool>& visited, int node) {
    visited[node] = true; // 标记当前节点为已访问
    cout << node << " "; // 输出当前节点

    // 遍历所有相邻节点
    for (int i = 0; i < matrix.size(); ++i) {
        if (matrix[node][i] == 1 && !visited[i]) {
            dfsMatrix(matrix, visited, i); // 递归访问
        }
    }
}

// 用于邻接链表的深度优先搜索
void dfsList(const vector<list<int>>& adjList, vector<bool>& visited, int node) {
    visited[node] = true; // 标记当前节点为已访问
    cout << node << " "; // 输出当前节点

    // 遍历所有相邻节点
    for (int neighbor : adjList[node]) {
        if (!visited[neighbor]) {
            dfsList(adjList, visited, neighbor); // 递归访问
        }
    }
}

int main() {
    // 示例：使用邻接矩阵
    vector<vector<int>> matrix = {
        {0, 1, 1, 0},
        {1, 0, 0, 1},
        {1, 0, 0, 1},
        {0, 1, 1, 0}
    };

    int vertices = matrix.size();
    vector<bool> visited(vertices, false); // 访问状态初始化
    cout << "DFS using adjacency matrix:" << endl;
    dfsMatrix(matrix, visited, 0); // 从节点 0 开始
    cout << endl;

    // 重置访问状态
    fill(visited.begin(), visited.end(), false);

    // 示例：使用邻接链表
    vector<list<int>> adjList = {
        {1, 2},   // 节点 0
        {0, 3},   // 节点 1
        {0, 3},   // 节点 2
        {1, 2}    // 节点 3
    };

    cout << "DFS using adjacency list:" << endl;
    dfsList(adjList, visited, 0); // 从节点 0 开始
    cout << endl;

    return 0;
}